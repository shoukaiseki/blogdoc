<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=gbk">
<title>蒋カイセキ 的博客</title>
<style type="text/css">
.blogcnt{line-height:160%;font-size:14px;text-align:left;word-wrap:break-word;}
.blogcnt *{line-height:160%;}
.blogcnt p{margin:0 0 10px;}
.blogcnt ul,.nbw-blog ol{margin:5px 0 5px 40px;padding:0}
.blogcnt em{font-style:italic;}
.blogcnt blockquote{font-size:1em;margin:auto 0 auto 35px;}
.blogcnt img{border:0;max-width:100%;}
</style>
</head>
<body style="color:#444444;">
<h1 id="blog-Title"><a href="index.html">蒋カイセキ 的博客</a></h1>
<div id="" style="padding:0 20px;">
	<h2 id="">java byte 却嬷匈x予文件名後嚎s成zip</h2>
	<h5 id="">2012-06-15 21:35:08&nbsp;&nbsp;&nbsp;<a href="http://blog.163.com/shoukaiseki/blog/static/19285614920125159358109/" target="_blank">查看原文&gt;&gt;</a></h5>
	<div class="" id="" style="padding:0 20px;">
		<div class="blogcnt" style="width:800px;"><br><br><pre class="prettyprint"  ><p><code><b><a rel="nofollow">package bennkyou.zip;<br><br>import java.io.*;<br>import java.lang.reflect.Array;<br>import java.util.*;<br>import java.util.zip.*;<br><br>/**<br> * 直接⒍M制byte流指定文件名後嚎s成zip格式,不必出文件再嚎s,<br> * 可增加安全性<br> * 可於鬏,web接口鬏<br> * @author 蒋カイセキ    Japan-Tokyo 2012-6-15<br> * @ブログ http://shoukaiseki.blog.163.com/<br> * @E-メ`ル jiang28555@Gmail.com<br> */<br>public class BufferedZip {<br> public static final int BUFFER = 1024;// 缓存大小<br><br> public static void main(String[] args) throws Exception {<br>  String s = "/**\n * 直接⒍M制byte流指定文件名後嚎s成zip格式,不必出文件再嚎s,\n * 可增加安全性\n * 可於鬏,web接口鬏\n * @author 蒋カイセキ    Japan-Tokyo 2012-6-15\n * @ブログ http://shoukaiseki.blog.163.com/\n * @E-メ`ル jiang28555@Gmail.com\n */\n\n";<br>  zipFile(s, "222.xml", "/tmp/del/zip/333.zip");<br>  <br>  //指定字符串嚎s後的文件名<br>  byte[] bytes = zipString(s, "2.xml");<br><br>  System.out.println("stored=" + ZipEntry.STORED);// O置嚎s方法<br>  System.out.println("deflated=" + ZipEntry.DEFLATED);// O置嚎s方法<br><br>  //可以y直接⒍M制出到zip文件<br>//  FileOutputStream fos=new FileOutputStream("/tmp/del/zip/zipa/1.zip");<br>//  fos.write(bytes);<br>//  fos.close();<br>  <br>  //<br>  Map&lt;String, byte[]&gt; map = unZipBytes(bytes);<br>  Set&lt;String&gt; keysSet = map.keySet();<br>  Iterator&lt;String&gt; iterator = keysSet.iterator();<br>  for (int i = 1; iterator.hasNext(); i++) {<br>   Object key = iterator.next();// key<br>   byte[] value = map.get(key);// value<br>   System.out.println(i + "\tkey=" + key + "\n" + new String(value));<br>  }<br>  System.out.println("KO");<br> }<br><br> /**<br>  * 解压缩zip文件流功能. 将ZIP_Byte二M制文件解K存放至map&lt;文件名,二M制&gt;中.<br>  * <br>  * @return<br>  * @throws Exception<br>  */<br> public static Map&lt;String, byte[]&gt; unZipBytes(byte[] bytes) throws Exception {<br>  ByteArrayInputStream bai = new ByteArrayInputStream(bytes);<br>  ZipInputStream zis = new ZipInputStream(bai);<br><br>  // ByteArrayOutputStream os=new ByteArrayOutputStream();<br>  // byte buf[] = new byte[1024];<br>  // // 省略循环<br>  // int numread = zis.read(buf);<br>  // os.write(buf, 0, numread);<br>  // InputStream is2 = new ByteArrayInputStream(os.toByteArray());<br><br>  ZipEntry ze = null;<br>  Map&lt;String, byte[]&gt; map = new HashMap();<br>  ByteArrayOutputStream bao = new ByteArrayOutputStream();<br>  while ((ze = zis.getNextEntry()) != null) {<br>   // 解压文件到指定的目录<br>   int size = 2048;<br>   // System.out.println(ze.getSize());<br>   // System.out.println(ze.getName());<br>   // System.out.println(ze.getMethod());<br>   // n^大小,分状入到流<br>   byte[] bs=new byte[0];<br>   while (true) {<br>    byte[] data = new byte[1024];<br>//    size = zis.read(data);<br>     size = zis.read(data, 0, 1024);<br>//     System.out.println("size="+size);<br>    if (size &gt; 0) {<br>     //因x入的流不足dataO置的n^大小的,byte到M遇到null,之後的值o效<br>     //故必指定size<br>     bao.write(data,0,size);<br>//    System.out.println("data="+new String(data));<br>    } else {<br>     break;<br>    }<br>    //在@Y不能用,因x入的流不足dataO置的n^大小的,byte到M遇到null之後的值o效<br>    //如要使用需要size作,作dest的有效L度<br>     bs=(byte[]) appEndArray(bs, data);<br>//     System.out.println("bs.size="+bs.length);<br>//     System.out.println("bs="+new String(bs));<br>   }<br>//   System.out.println(new String(bao.toByteArray()));<br>   //可以y直接⒍M制出到文件<br>//   FileOutputStream fos=new FileOutputStream("/tmp/del/zip/zipx/1.xml");<br>//   fos.write(bao.toByteArray());<br>//   fos.close();<br>   <br>   //<br>   map.put(ze.getName(), bao.toByteArray());<br>//   System.out.println(new String(bs));<br>  }<br>  bao.close();<br>  zis.close();<br>  bai.close();<br>  return map;<br> }<br> <br> static Object appEndArray(Object source,Object destination){<br>//  System.out.println("source="+new String((byte[])source));<br>//  System.out.println("destination="+new String((byte[])destination));<br>  Class componentType=source.getClass().getComponentType();<br>  int length=Array.getLength(source);<br>  int lengthD=Array.getLength(destination);<br>  Object newArray=Array.newInstance(componentType, length+lengthD);<br>  System.arraycopy(source, 0, newArray,0,length);<br>  System.arraycopy(destination,0,newArray,length,lengthD);<br>//  System.out.println("newArray="+new String((byte[])newArray));<br>  return newArray;<br> }<br><br><br> /**<br>  * 直接⒆址串嚎s成文件的zipM行魉,文件名nodeName,value字符串热<br>  * <br>  * @param value<br>  * @param nodeName<br>  * @return<br>  * @throws IOException<br>  */<br> public static byte[] zipString(String value, String nodeName)<br>   throws IOException {<br>  ByteArrayOutputStream bao = new ByteArrayOutputStream();<br>  ZipOutputStream zos = new ZipOutputStream(bao);<br>  ZipEntry ze = null;<br>  ze = new ZipEntry(nodeName);<br>  // ze.setMethod(ze.STORED);//O置嚎s方法<br>  ze.setSize(value.getBytes().length);<br>  ze.setTime(System.currentTimeMillis());<br>  zos.putNextEntry(ze);<br>  System.out.println(value.length());<br>  System.out.println(value.getBytes().length);<br>  byte[] buf = new byte[BUFFER];<br>  // zos.write(value.getBytes(), 0, value.length());<br>  zos.write(value.getBytes());<br><br>  // while ((readLen=bao.read(buf, 0, BUFFER))!=-1) {<br>  // zos.write(buf, 0, readLen);<br>  // }<br>  zos.close();<br>  return bao.toByteArray();<br> }<br><br> /**<br>  * zip压缩功能. 压缩baseDir(文件夹目录)下所有文件，包括子目录<br>  * <br>  * @throws Exception<br>  */<br> public static void zipFile(String value, String nodeName, String fileName)<br>   throws Exception {<br>  byte[] bytes = zipString(value, nodeName);<br>  File file = new File(fileName);<br>  FileOutputStream fos = new FileOutputStream(file);<br>  fos.write(bytes);<br> }<br> // /**<br> // * 解压缩zip文件流功能.<br> // * 将ZIP_Byte二M制文件解K存放至map&lt;文件名,二M制&gt;中.<br> // * @return<br> // * @throws Exception<br> // */<br> // public Map&lt;String, byte[]&gt; upZipBytes(byte[] bytes) throws Exception{<br> // ByteArrayInputStream bai = new ByteArrayInputStream(bytes);<br> // ZipInputStream zis=new ZipInputStream(bai);<br> // ZipEntry ze=null;<br> // Map&lt;String,byte[]&gt; map=new HashMap();<br> // while((ze=zis.getNextEntry()) != null){<br> // System.out.println(ze.getExtra());<br> // map.put(ze.getName(), ze.getExtra());<br> // }<br> // zis.close();<br>}<br></a></b></code> </p></pre></div>
	</div>
</div>
</body>
</html>